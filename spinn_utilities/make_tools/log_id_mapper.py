# Copyright (c) 2018-2019 The University of Manchester
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

import datetime
import os
from spinn_utilities.make_tools.make_utils import find_dict

DICTIONARY_HEADER = "Id,Preface,Original\n" \
                    ",DO NOT EDIT,THIS FILE WAS AUTOGENERATED BY MAKE\n"
DELETE_WARING = "Warning deleting existing dict file {}"
NO_DICT_EXCEPTION = (
    "No dict file found at {}. Please make sure your environment variables "
    "are set correctly and run a full system make.")
LEVELS = {"log_info(": "[INFO]",
          "log_error(": "[ERROR]",
          "log_debug(": "[DEBUG]",
          "log_warning(": "[WARNING]"}


class LogIdMapper(object):
    __slots__ = [
        # File to hold dictionary mappings
        "_dict",
        # Max id found so far
        "_max_id",
        # Path of source file
        "_src",
    ]

    def __init__(self, src, dest):
        """
        Creates a log mapper for this source and destination
        :param str src: Path to source file
        :param ste dest: Path to destination file
        """
        self._src = src
        self._dict = find_dict()
        # Check the dict file exits.
        if not os.path.exists(self._dict):
            raise Exception(NO_DICT_EXCEPTION)
        # Added a line saying what you converted
        with open(self._dict, 'a') as dict_f:
            dict_f.write("{},{},{}\n".format(
                self._src.replace(",", ";"), dest.replace(",", ";"),
                datetime.datetime.now().strftime("%Y-%m-%d %H:%M")))

        self._max_id = 0
        with open(self._dict, 'r') as dict_f:
            for line in dict_f:
                parts = line.strip().split(",", 2)
                if len(parts) == 3 and parts[0].isdigit():
                    id = int(parts[0])
                    if id > self._max_id:
                        self._max_id = id

    def __enter__(self):
        # nothing yet
        return self

    def __exit__(self, type, value, traceback):
        # nothing yet
        pass

    def add_log(self, line_num, original, log):
        """
        Adds a mapping for this log
        :param int line_num: Line number in original file. (Zero based)
        :param str original: Original log message
        :param str log:  log level
        :return: id for this message
        """
        self._max_id += 1
        with open(self._dict, 'a') as mess_f:
            # Remove commas from filenames for csv format
            # Remove start and end quotes from original
            mess_f.write("{},{} ({}: {}): ,{}\n".format(
                self._max_id, LEVELS[log],
                os.path.basename(self._src).replace(",", ";"),
                line_num + 1,
                original))
        return self._max_id

    @staticmethod
    def reset_logs():
        """
        Clears any previous log mappings and prepares a new blank one
        """
        dict = find_dict()
        if os.path.exists(dict):
            print(DELETE_WARING.format(dict))
        with open(dict, 'w') as dict_f:
            dict_f.write(DICTIONARY_HEADER)
